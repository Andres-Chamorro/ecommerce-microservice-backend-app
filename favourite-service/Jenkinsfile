pipeline {
    agent any
    
    environment {
        // Service Configuration
        SERVICE_NAME = 'favourite-service'
        SERVICE_PORT = '8600'
        
        // Build Configuration
        MAVEN_OPTS = '-Xmx2048m'
        BUILD_TAG = "${env.BUILD_NUMBER}"
        
        // Docker - Local para Minikube
        IMAGE_NAME = "${SERVICE_NAME}"
        
        // Minikube Configuration
        K8S_NAMESPACE = 'ecommerce-dev'
    }
    
    parameters {
        booleanParam(
            name: 'SKIP_TESTS',
            defaultValue: false,
            description: 'Saltar pruebas unitarias e integracion'
        )
        booleanParam(
            name: 'SKIP_DEPLOY',
            defaultValue: false,
            description: 'Saltar despliegue en Minikube'
        )
    }
    
    stages {
        stage('Checkout') {
            steps {
                echo "[DEV] Clonando repositorio de ${SERVICE_NAME}..."
                checkout scm
            }
        }
        
        stage('Build Maven') {
            steps {
                script {
                    echo "[DEV] Compilando ${SERVICE_NAME} con Maven..."
                    dir('favourite-service') {
                        sh 'mvn clean package -DskipTests'
                    }
                }
            }
        }
        
        stage('Unit Tests') {
            when {
                expression { params.SKIP_TESTS == false }
            }
            steps {
                script {
                    echo "[DEV] Ejecutando pruebas unitarias de ${SERVICE_NAME}..."
                    dir('favourite-service') {
                        sh 'mvn test -Dtest=*ServiceTest,*ResourceTest'
                    }
                }
            }
            post {
                always {
                    archiveArtifacts artifacts: 'favourite-service/target/surefire-reports/**/*.xml, favourite-service/target/surefire-reports/**/*.txt', allowEmptyArchive: true
                    echo "Reportes de pruebas guardados en artifacts"
                }
            }
        }
        
        stage('Build Docker Image') {
            steps {
                script {
                    echo "[DEV] Construyendo imagen Docker de ${SERVICE_NAME}..."
                    sh """
                        # Construir imagen con Docker
                        docker build -t ${IMAGE_NAME}:dev-${BUILD_TAG} -f favourite-service/Dockerfile .
                        docker tag ${IMAGE_NAME}:dev-${BUILD_TAG} ${IMAGE_NAME}:dev-latest
                        
                        # Transferir imagen directamente a Minikube usando pipe
                        docker save ${IMAGE_NAME}:dev-${BUILD_TAG} | docker exec -i minikube ctr -n k8s.io images import -
                        
                        # Verificar que la imagen existe en Minikube
                        docker exec minikube crictl images | grep ${IMAGE_NAME} || echo "WARNING: Imagen no encontrada en Minikube"
                    """
                }
            }
        }
        
        stage('Deploy to Minikube') {
            when {
                expression { params.SKIP_DEPLOY == false }
            }
            steps {
                script {
                    echo "[DEV] Desplegando ${SERVICE_NAME} en Minikube..."
                    
                    sh """
                        # Verificar conexion
                        docker exec minikube /var/lib/minikube/binaries/v1.34.0/kubectl --kubeconfig=/etc/kubernetes/admin.conf cluster-info
                        
                        # Crear namespace si no existe
                        docker exec minikube /var/lib/minikube/binaries/v1.34.0/kubectl --kubeconfig=/etc/kubernetes/admin.conf get namespace ${K8S_NAMESPACE} || docker exec minikube /var/lib/minikube/binaries/v1.34.0/kubectl --kubeconfig=/etc/kubernetes/admin.conf create namespace ${K8S_NAMESPACE}
                        
                        # Aplicar deployment directamente con pipe
                        cat <<'EOFYAML' | docker exec -i minikube /var/lib/minikube/binaries/v1.34.0/kubectl --kubeconfig=/etc/kubernetes/admin.conf apply -f -
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ${SERVICE_NAME}
  namespace: ${K8S_NAMESPACE}
spec:
  replicas: 1
  selector:
    matchLabels:
      app: ${SERVICE_NAME}
  template:
    metadata:
      labels:
        app: ${SERVICE_NAME}
    spec:
      containers:
      - name: ${SERVICE_NAME}
        image: ${IMAGE_NAME}:dev-${BUILD_TAG}
        ports:
        - containerPort: ${SERVICE_PORT}
        imagePullPolicy: Never
        env:
        - name: SPRING_PROFILES_ACTIVE
          value: "dev"
---
apiVersion: v1
kind: Service
metadata:
  name: ${SERVICE_NAME}
  namespace: ${K8S_NAMESPACE}
spec:
  selector:
    app: ${SERVICE_NAME}
  ports:
  - port: ${SERVICE_PORT}
    targetPort: ${SERVICE_PORT}
  type: ClusterIP
EOFYAML
                        
                        # Esperar a que el deployment este listo
                        docker exec minikube /var/lib/minikube/binaries/v1.34.0/kubectl --kubeconfig=/etc/kubernetes/admin.conf rollout status deployment/${SERVICE_NAME} -n ${K8S_NAMESPACE} --timeout=180s || echo "WARNING: ${SERVICE_NAME} no esta listo"
                    """
                }
            }
        }
        
        stage('Verify Deployment') {
            when {
                expression { params.SKIP_DEPLOY == false }
            }
            steps {
                script {
                    echo "[DEV] Verificando despliegue de ${SERVICE_NAME}..."
                    
                    sh """
                        echo "Estado de pods:"
                        docker exec minikube /var/lib/minikube/binaries/v1.34.0/kubectl --kubeconfig=/etc/kubernetes/admin.conf get pods -n ${K8S_NAMESPACE} -l app=${SERVICE_NAME}
                        
                        echo "Estado de servicios:"
                        docker exec minikube /var/lib/minikube/binaries/v1.34.0/kubectl --kubeconfig=/etc/kubernetes/admin.conf get svc -n ${K8S_NAMESPACE} ${SERVICE_NAME}
                        
                        POD_STATUS=\$(docker exec minikube /var/lib/minikube/binaries/v1.34.0/kubectl --kubeconfig=/etc/kubernetes/admin.conf get pods -n ${K8S_NAMESPACE} -l app=${SERVICE_NAME} -o jsonpath='{.items[0].status.phase}' 2>/dev/null || echo 'NotFound')
                        echo "Estado del pod: \$POD_STATUS"
                        
                        if [ "\$POD_STATUS" = "Running" ]; then
                            echo "${SERVICE_NAME} esta corriendo correctamente en Minikube"
                        else
                            echo "WARNING: ${SERVICE_NAME} no esta en estado Running - revisar con kubectl describe pod"
                        fi
                    """
                }
            }
        }
        
        stage('Integration Tests') {
            when {
                expression { params.SKIP_TESTS == false && params.SKIP_DEPLOY == false }
            }
            steps {
                script {
                    echo "[DEV] Configurando port-forwards para pruebas de integraciÃ³n..."
                    
                    // Iniciar port-forwards en background
                    sh '''
                        # FunciÃ³n para hacer port-forward en background
                        start_port_forward() {
                            SERVICE=$1
                            PORT=$2
                            NAMESPACE=${3:-ecommerce-dev}
                            
                            echo "Port-forwarding $SERVICE:$PORT..."
                            kubectl port-forward -n $NAMESPACE svc/$SERVICE $PORT:$PORT > /dev/null 2>&1 &
                            PF_PID=$!
                            echo $PF_PID >> /tmp/port-forward-pids.txt
                            sleep 2
                        }
                        
                        # Limpiar port-forwards anteriores
                        rm -f /tmp/port-forward-pids.txt
                        
                        # Iniciar port-forwards para todos los servicios
                        start_port_forward user-service 8700
                        start_port_forward order-service 8300
                        start_port_forward payment-service 8400
                        start_port_forward product-service 8500
                        start_port_forward shipping-service 8600
                        start_port_forward favourite-service 8800
                        
                        echo "âœ… Port-forwards configurados"
                        sleep 3
                    '''
                    
                    try {
                        echo "[DEV] Ejecutando pruebas de integraciÃ³n..."
                        dir('tests/integration') {
                            sh '''
                                if [ -f pom.xml ]; then
                                    # Las pruebas ahora pueden usar localhost gracias a port-forward
                                    mvn test -Dtest=*IntegrationTest || echo "âš ï¸ Algunas pruebas de integraciÃ³n fallaron"
                                else
                                    echo "No hay pruebas de integraciÃ³n configuradas"
                                fi
                            '''
                        }
                    } finally {
                        // Limpiar port-forwards
                        sh '''
                            echo "Limpiando port-forwards..."
                            if [ -f /tmp/port-forward-pids.txt ]; then
                                while read pid; do
                                    kill $pid 2>/dev/null || true
                                done < /tmp/port-forward-pids.txt
                                rm -f /tmp/port-forward-pids.txt
                            fi
                            echo "âœ… Port-forwards limpiados"
                        '''
                    }
                }
            }
        }
        
        stage('Code Coverage Report') {
            when {
                expression { params.SKIP_TESTS == false }
            }
            steps {
                script {
                    echo "[DEV] Generando reporte de cobertura de codigo (unitarias + integracion)..."
                    dir('favourite-service') {
                        sh 'mvn jacoco:report || echo "WARNING: No se pudo generar reporte JaCoCo"'
                    }
                }
            }
            post {
                always {
                    jacoco(
                        execPattern: 'favourite-service/target/jacoco.exec',
                        classPattern: 'favourite-service/target/classes',
                        sourcePattern: 'favourite-service/src/main/java',
                        exclusionPattern: '**/*Test*.class'
                    )
                }
            }
        }

    }

    post {
        always {
            echo "[DEV] Limpiando workspace..."
            cleanWs()
        }
        success {
            echo """
            ========================================
            Pipeline DEV de ${SERVICE_NAME} completado
            ========================================
            Imagen: ${IMAGE_NAME}:dev-${BUILD_TAG}
            Namespace: ${K8S_NAMESPACE}
            Ambiente: Minikube (Local)
            ========================================
            """
        }
        failure {
            echo "Pipeline DEV de ${SERVICE_NAME} fallo"
        }
    }
}

