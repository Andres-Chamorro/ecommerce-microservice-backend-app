pipeline {
    agent any
    
    environment {
        // Java Configuration
        JAVA_HOME = '/opt/java/openjdk'
        PATH = "/root/google-cloud-sdk/bin:${JAVA_HOME}/bin:${env.PATH}"
        
        // GCP & Kubernetes
        USE_GKE_GCLOUD_AUTH_PLUGIN = 'True'
        K8S_NAMESPACE = 'ecommerce-staging'
        
        // Service Configuration
        SERVICE_NAME = 'favourite-service'
        SERVICE_PORT = '8800'
        
        // Docker Registry
        DOCKER_REGISTRY = 'us-central1-docker.pkg.dev/ecommerce-microservices-476519/ecommerce-registry' // Cambiar si usas Docker Hub o GCR
        IMAGE_NAME = "${DOCKER_REGISTRY}/${SERVICE_NAME}"
        
        // Build Reference
        BUILD_TAG = "${env.BUILD_NUMBER}"
        DEV_BUILD_NUMBER = "${env.DEV_BUILD_NUMBER ?: 'latest'}" // N√∫mero de build de DEV
    }
    
    parameters {
        string(
            name: 'DEV_BUILD_NUMBER',
            defaultValue: 'latest',
            description: 'N√∫mero de build de DEV a desplegar (ej: 123) o "latest"'
        )
        booleanParam(
            name: 'SKIP_E2E_TESTS',
            defaultValue: false,
            description: 'Saltar pruebas E2E'
        )
        booleanParam(
            name: 'SKIP_PERFORMANCE_TESTS',
            defaultValue: false,
            description: 'Saltar pruebas de rendimiento'
        )
    }
    
    stages {
        stage('Checkout') {
            steps {
                echo "üîÑ [STAGING] Clonando repositorio de ${SERVICE_NAME}..."
                checkout scm
            }
        }
        
        stage('Pull Image from Dev') {
            steps {
                script {
                    echo "üì• [STAGING] Obteniendo imagen de DEV..."
                    def devTag = params.DEV_BUILD_NUMBER == 'latest' ? 'dev-latest' : "dev-${params.DEV_BUILD_NUMBER}"
                    
                    sh """
                        echo "Pulling imagen: ${IMAGE_NAME}:${devTag}"
                        docker pull ${IMAGE_NAME}:${devTag}
                    """
                }
            }
        }
        
        stage('Retag Image') {
            steps {
                script {
                    echo "üè∑Ô∏è [STAGING] Re-etiquetando imagen para staging..."
                    def devTag = params.DEV_BUILD_NUMBER == 'latest' ? 'dev-latest' : "dev-${params.DEV_BUILD_NUMBER}"
                    
                    sh """
                        docker tag ${IMAGE_NAME}:${devTag} ${IMAGE_NAME}:staging-${BUILD_TAG}
                        docker tag ${IMAGE_NAME}:${devTag} ${IMAGE_NAME}:staging-latest
                        
                        echo "Subiendo imagen a registry..."
                        docker push ${IMAGE_NAME}:staging-${BUILD_TAG}
                        docker push ${IMAGE_NAME}:staging-latest
                    """
                }
            }
        }
        
        stage('Deploy to GKE Staging') {
            steps {
                script {
                    echo "‚ò∏Ô∏è [STAGING] Desplegando ${SERVICE_NAME} en GKE Staging..."
                    
                    sh """
                        . /root/google-cloud-sdk/path.bash.inc
                        
                        # Crear namespace si no existe
                        kubectl create namespace ${K8S_NAMESPACE} --dry-run=client -o yaml | kubectl apply -f -
                        
                        # Aplicar deployment desde k8s/microservices
                        if [ -f k8s/microservices/${SERVICE_NAME}-deployment.yaml ]; then
                            # Actualizar la imagen en el deployment
                            kubectl set image deployment/${SERVICE_NAME} ${SERVICE_NAME}=${IMAGE_NAME}:staging-${BUILD_TAG} -n ${K8S_NAMESPACE} || \
                            kubectl apply -f k8s/microservices/${SERVICE_NAME}-deployment.yaml -n ${K8S_NAMESPACE}
                        else
                            echo "‚ö†Ô∏è No se encontr√≥ deployment YAML, creando uno temporal..."
                            cat <<EOF | kubectl apply -f -
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ${SERVICE_NAME}
  namespace: ${K8S_NAMESPACE}
spec:
  replicas: 2
  selector:
    matchLabels:
      app: ${SERVICE_NAME}
  template:
    metadata:
      labels:
        app: ${SERVICE_NAME}
    spec:
      containers:
      - name: ${SERVICE_NAME}
        image: ${IMAGE_NAME}:staging-${BUILD_TAG}
        ports:
        - containerPort: ${SERVICE_PORT}
        imagePullPolicy: Always
---
apiVersion: v1
kind: Service
metadata:
  name: ${SERVICE_NAME}
  namespace: ${K8S_NAMESPACE}
spec:
  selector:
    app: ${SERVICE_NAME}
  ports:
  - port: ${SERVICE_PORT}
    targetPort: ${SERVICE_PORT}
  type: LoadBalancer
EOF
                        fi
                    """
                }
            }
        }
        
        stage('Wait for Rollout') {
            steps {
                script {
                    echo "‚è≥ [STAGING]Esperando a que el despliegue est√© listo..."
                    
                    sh """
                        . /root/google-cloud-sdk/path.bash.inc
                        
                        kubectl rollout status deployment/${SERVICE_NAME} -n ${K8S_NAMESPACE} --timeout=600s || echo "‚ö†Ô∏è Rollout tom√≥ m√°s tiempo del esperado, continuando..."
                        
                        echo "‚úÖ Despliegue completado"
                    """
                }
            }
        }
        
        stage('E2E Tests') {
            when {
                expression { params.SKIP_E2E_TESTS == false }
            }
            steps {
                script {
                    echo "üß™ [STAGING]Ejecutando pruebas E2E..."
                    
                    sh '''
                        . /root/google-cloud-sdk/path.bash.inc
                        
                        # Obtener la URL del servicio (esperar hasta 2 minutos por la IP externa)
                        echo "‚è≥Esperando IP externa del LoadBalancer..."
                        i=1
                        while [ $i -le 24 ]; do
                            SERVICE_IP=$(kubectl get svc ${SERVICE_NAME} -n ${K8S_NAMESPACE} -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null)
                            if [ -n "$SERVICE_IP" ]; then
                                echo "‚úÖIP externa obtenida: $SERVICE_IP"
                                break
                            fi
                            echo "Intento $i/24:Esperando IP externa..."
                            sleep 5
                            i=$((i + 1))
                        done
                        
                        if [ -z "$SERVICE_IP" ]; then
                            echo "‚ö†Ô∏èNo se pudo obtener IP externa, usando port-forward como fallback"
                            kubectl port-forward -n ${K8S_NAMESPACE} svc/${SERVICE_NAME} ${SERVICE_PORT}:${SERVICE_PORT} &
                            PORT_FORWARD_PID=$!
                            sleep 5
                            SERVICE_URL="localhost"
                        else
                            SERVICE_URL="$SERVICE_IP"
                        fi
                        
                        echo "üåêService URL: http://$SERVICE_URL:${SERVICE_PORT}"
                        
                        # Guardar variables para usar fuera del script
                        echo "$SERVICE_URL" > /tmp/service_url.txt
                        echo "$PORT_FORWARD_PID" > /tmp/port_forward_pid.txt
                    '''
                    
                    // Ejecutar pruebas E2E usando dir() para mantener el contexto
                    if (fileExists('tests/e2e/pom.xml')) {
                        dir('tests/e2e') {
                            sh '''
                                export JAVA_HOME=/opt/java/openjdk
                                export PATH=$JAVA_HOME/bin:$PATH
                                
                                SERVICE_URL=$(cat /tmp/service_url.txt)
                                echo "Ejecutando pruebas E2E contra: http://$SERVICE_URL:${SERVICE_PORT}"
                                mvn test -Dtest=*E2ETest -Dservice.url=http://$SERVICE_URL:${SERVICE_PORT} -Dservice.name=${SERVICE_NAME} || echo "Algunas pruebas E2E fallaron"
                            '''
                        }
                    } else {
                        echo "No hay pruebas E2E configuradas"
                    }
                    
                    // Limpiar port-forward si se us√≥
                    sh '''
                        if [ -f /tmp/port_forward_pid.txt ]; then
                            PORT_FORWARD_PID=$(cat /tmp/port_forward_pid.txt)
                            if [ -n "$PORT_FORWARD_PID" ] && [ "$PORT_FORWARD_PID" != "" ]; then
                                kill $PORT_FORWARD_PID 2>/dev/null || true
                            fi
                        fi
                        rm -f /tmp/service_url.txt /tmp/port_forward_pid.txt
                    '''
                }
            }
            post {
                always {
                    script {
                        if (fileExists('tests/e2e/target/surefire-reports')) {
                            archiveArtifacts artifacts: 'tests/e2e/target/surefire-reports/**/*.xml', allowEmptyArchive: true
                            echo ' Reportes E2E archivados'
                        } else {
                            echo '? No hay reportes E2E para archivar (no hay pruebas implementadas)'
                        }
                    }
                }
            }
        }
        
        stage('Performance Tests') {
            when {
                expression { params.SKIP_PERFORMANCE_TESTS == false }
            }
            steps {
                script {
                    echo "‚ö° [STAGING]Ejecutando pruebas de rendimiento con Locust..."
                    
                    sh '''
                        . /root/google-cloud-sdk/path.bash.inc
                        
                        # Obtener la URL del servicio (esperar IP externa)
                        echo "‚è≥ Obteniendo IP del servicio..."
                        for i in {1..12}; do
                            SERVICE_IP=$(kubectl get svc ${SERVICE_NAME} -n ${K8S_NAMESPACE} -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null)
                            if [ -n "$SERVICE_IP" ]; then
                                echo "‚úÖ IP obtenida: $SERVICE_IP"
                                break
                            fi
                            sleep 5
                        done
                        
                        if [ -z "$SERVICE_IP" ]; then
                            SERVICE_URL="localhost"
                            echo "‚ö†Ô∏è Usando localhost como fallback"
                        else
                            SERVICE_URL="$SERVICE_IP"
                        fi
                        
                        echo "üåêService URL: http://$SERVICE_URL:${SERVICE_PORT}"
                        
                        # Instalar locust si no est√° instalado
                        pip3 install --user locust || echo "Error instalando Locust"
                    '''
                    
                    // Ejecutar pruebas de rendimiento usando dir()
                    if (fileExists('tests/performance/locustfile.py')) {
                        dir('tests/performance') {
                            sh '''
                                echo "üìäEjecutando pruebas de rendimiento..."
                                
                                # Obtener IP del servicio
                                SERVICE_IP=$(kubectl get svc ${SERVICE_NAME} -n ${K8S_NAMESPACE} -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null)
                                if [ -z "$SERVICE_IP" ]; then
                                    SERVICE_URL="localhost"
                                else
                                    SERVICE_URL="$SERVICE_IP"
                                fi
                                
                                python3 -m locust -f locustfile.py --host=http://$SERVICE_URL:${SERVICE_PORT} \
                                    --users 50 --spawn-rate 5 --run-time 2m --headless \
                                    --html=locust-report-${SERVICE_NAME}.html || echo "‚ö†Ô∏è Pruebas de rendimiento completadas con warnings"
                                
                                echo "‚úÖReporte generado"
                            '''
                        }
                    } else {
                        echo "‚ÑπÔ∏è No hay pruebas de rendimiento configuradas"
                    }
                }
            }
            post {
                always {
                    script {
                        if (fileExists("tests/performance/locust-report-${SERVICE_NAME}.html")) {
                            archiveArtifacts artifacts: "tests/performance/locust-report-${SERVICE_NAME}.html", allowEmptyArchive: false
                        } else {
                            echo "‚ÑπÔ∏è No se gener√≥ reporte de rendimiento"
                        }
                    }
                }
            }
        }
        
        stage('Generate Test Report') {
            steps {
                script {
                    echo "üìä [STAGING] Generando reporte de pruebas..."
                    
                    sh """
                        echo "==================================="
                        echo "REPORTE DE PRUEBAS - STAGING"
                        echo "==================================="
                        echo "Servicio: ${SERVICE_NAME}"
                        echo "Build: ${BUILD_TAG}"
                        echo "Namespace: ${K8S_NAMESPACE}"
                        echo "Imagen: ${IMAGE_NAME}:staging-${BUILD_TAG}"
                        echo "==================================="
                    """
                }
            }
        }
        
        stage('Verify Health Checks') {
            steps {
                script {
                    echo "üè• [STAGING] Verificando health checks..."
                    
                    sh """
                        . /root/google-cloud-sdk/path.bash.inc
                        
                        echo "üìä Estado de pods:"
                        kubectl get pods -n ${K8S_NAMESPACE} -l app=${SERVICE_NAME}
                        
                        echo "üìä Estado de servicios:"
                        kubectl get svc -n ${K8S_NAMESPACE} ${SERVICE_NAME}
                        
                        POD_STATUS=\$(kubectl get pods -n ${K8S_NAMESPACE} -l app=${SERVICE_NAME} -o jsonpath='{.items[0].status.phase}' 2>/dev/null || echo 'NotFound')
                        
                        if [ "\$POD_STATUS" = "Running" ]; then
                            echo "‚úÖ ${SERVICE_NAME} est√° corriendo correctamente en GKE Staging"
                        else
                            echo "‚ö†Ô∏è WARNING: ${SERVICE_NAME} no est√° en estado Running"
                            exit 1
                        fi
                    """
                }
            }
        }
    }
    
    post {
        always {
            echo "üßπ [STAGING] Limpiando workspace..."
            cleanWs()
        }
        success {
            echo """
            ‚úÖ ========================================
            ‚úÖ Pipeline STAGING de ${SERVICE_NAME} completado
            ‚úÖ ========================================
            üì¶ Imagen: ${IMAGE_NAME}:staging-${BUILD_TAG}
            ‚ò∏Ô∏è  Namespace: ${K8S_NAMESPACE}
            üéØ Ambiente: GKE Staging
            üß™ Pruebas E2E: Ejecutadas
            ‚ö° Pruebas Performance: Ejecutadas
            ‚úÖ ========================================
            """
        }
        failure {
            echo "‚ùå Pipeline STAGING de ${SERVICE_NAME} fall√≥"
        }
    }
}

